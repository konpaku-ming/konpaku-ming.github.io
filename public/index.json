
[{"content":"现在是 2 月 6 号的凌晨 0:26，我开始写这篇日记，大致交代一下这几天我的工作（虽然是白忙活）。不然好像我一直在当鸽子，实则这几天牢的要死。\n2 月 3 号我开了新符卡的工作，大概在下午完成。但问题是之前表现一直很好的搜索型避弹 AI 面对这张符卡表现很差，后面所做的一切工作其实只有这一点：全避这张符。\n然后呢，然后走上了一条不归路并开始坐牢\u0026hellip;\nBefore Reading\r#\r很早就红心了的曲子，前几天网易云随机播红心歌单，播到这首时意外触动到了，有许多莫名的感受。经常一段时间没听过某首歌，忽然再认真听一遍，会感受到有些强烈的震颤，好像在怀念什么。\n我之前还把这首和永啼鸟弄混过来着。然而这首是风神少女，永啼鸟好像是不死组的几首来着，按理说不应该混。不过由于是粽子，好像也听不出什么原曲😂（我把这首跟风神少女同时放，才能听出来副歌部分有点像\u0026hellip;）\n鳥よ\r#\r这次弹幕的主题也是源于这首歌吧，像鸟一样，想要去强调 “飞行感” 与 “自由感” ，但是又不完全是这种飞行幻想。这首歌所属的专辑《娶》想要讲述的是人与妖之间的羁绊吧，所以我对这张符卡的最后一个关键词是 “思恋” 。这也是为什么我用了很多自机狙，为什么第三阶段 Boss 要锁定自机的位置俯冲，我希望这张符卡能够体现这种命运的牵连感。\n然而很大的问题在于，之前的避弹逻辑在处理自机狙的时候，表现是相对较差的，它不会有引弹的意识。最后我用了非常抽象的方式来解决这个问题，这里暂且按下不表。\n弹幕分成三个阶段：第一阶段 Boss 扇动翅膀（做的不是很像扇动）发射弹幕，第二阶段 Boss 下压，发射撞到边界会反弹并产生大量龙鳞弹的自机狙。第三阶段 Boss 俯冲并在过程中散射飞羽，飞羽会减速到停止，在下一次俯冲时消弹。\n最终效果见 传送门 。\nRL 从入门到入土（???）\r#\r我们说到：之前的避弹逻辑在面对这张符的表现比较差，具体体现在这几点上：\n会莫名奇妙的撞第一阶段的中玉。明明密度不大，但就是会撞。\n不会引第二阶段的狙。这其实是一个很麻烦的问题，第二阶段的 water_drop 弹幕第一次碰到墙壁时会发生反弹，并且产生大量龙鳞弹向周围散射。\nfinal scene 里面是用两个底角引狙，散射产生的龙鳞弹轨迹很集中，也不影响引弹的路线。然而如果你像 dogger 一样不会引：\n其实这张还不算散的，如果狙的时候贴近 Boss ，让自机狙的子弹先散开，最后出来的龙鳞弹会糊满整个屏幕。\n不会躲第三阶段 Boss 的俯冲。如果处在俯冲的轨道上，靠 Boss 的斥力来躲撞击是来不及的。但是自机在飞羽静止后也会感到危险，于是倾向于留在原地（下一波被创亖）。\n我当时觉得后面两个问题都是搜索式本身很难克服的弊端，那干脆我们不做搜索式了吧。于是让 copilot 写了个训练避弹 AI 的计划书，在不懂原理的情况下就开干了，先采样就采了 20 分钟，之后又是用 PPO 又是蒸馏压缩，最后一看结果只会上下乱斗（蒸馏蒸得都不会左右移动了）。把学习轮次开大，后续才看的出来像是在避弹。以上是 2 月 4 号的成果， 5 号接着搞，想着怎么提高训练效果。第一轮训练出来的结果都活不过 100 帧，那后续的迭代自然也是泡汤了。搞了大半天完全没有效果，最后还是选择了放弃。\n半自动飞机\r#\r最后还是只能转会搜索型 AI ，先是新加了功能：分析有没有自机狙，影响后续风险的判断。加了这条后第一阶段就没什么问题了，主要还是第二阶段不会引弹和第三阶段站着不动被创亖。这时候想到的解决方案是：给一个引导的接口，让人类来决定“大方向”，也就是引导 AI 朝某个点走。最后落地的方案是用键盘上的 1~6 来表示画面左右两侧的上中下共 $6$ 个点，按下按键 AI 就会倾向于往那个点靠近。之后修了修再调调参，就是 final scene 了。那里面第二阶段就是交替向两个底角引导，连带狙一起，反弹产生的龙鳞弹就很规则了。\n第三阶段其实也是靠这个引导功能， AI 会探查能去到引导的目标点的安全通道，所以最后能够在停止的弹幕中做移动，调整位置躲开俯冲。不过即使如此，还是试了不少次才出了一发全避。\n人工队大胜利\r#\r然而增加引导功能后，我先是发现第一阶段的弹幕通过引狙也能引得很干净，这样手动过这张符的难度就集中在第三阶段了。一开始我是想在下面穿静止弹幕层，凭运气出一发。后来发现顶层其实不会被飞羽打到，只要不被体术就很安全，后来就一直尝试上避第三阶段。只要抓好第二阶段到第三阶段的那个消弹时间，就可以在第一波俯冲的同时拉到最上方了。\n这样看的话，这张符其实纯姿势。但是我做的时候本意是让 AI 来打，所以加了好几次弹幕量，看来也是不影响了。\n开始做符卡后，也是因为我收不了自己做的符才开始做 Bullet-Dodger 的，结果这张符反而是人工队表现更好，也算是可喜可贺了。\nNext Dream\u0026hellip;\r#\r这个避弹的项目估计也就到这里为止了，后续如果我有好好搞懂机器学习这一块的话，或许会重启这个项目。不过现在我已经做了三天牢了，我先需要睡个好觉，然后好好玩一天。\n后面做些什么呢，那是睡醒之后才该去考虑的事。\n","date":"6 February 2026","externalUrl":null,"permalink":"/posts/one-last-spellcard/","section":"Posts","summary":"","title":"One Last Spell Card","type":"posts"},{"content":"","date":"6 February 2026","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"6 February 2026","externalUrl":null,"permalink":"/","section":"Youming's Gensokyo","summary":"","title":"Youming's Gensokyo","type":"page"},{"content":"Ciallo～(∠・ω\u0026lt; )⌒★\nBullet Dodger 其实就是之前做的自动避弹 AI ，今天把它彻底优化了一下，看上去像个有趣的小项目了。目前算是做了初版，不过后面也不知道会不会再优化（笑），最近精力不佳，可能跟我睡觉变早有关，反正特别容易累。\n目前仓库还没公开，后面做完了会把代码全部放出来，还包括我几张符卡的代码。\nBefore Reading\r#\r本期弹幕的主题就是这首歌。想做出 “梦境” 和 “神秘” 的感觉来着，但是最后呈现反而更像是庄严感。\n原篇好像是小说来着，原谅我没看过（估计看过的多是玩贴吧和喵玉殿的老资历了）。歌是真的很好听，两位歌姬的声线也很符合我想象中的莲子和梅莉，不过原曲却跟秘封没什么关系呢。\n话说原曲和竹之花是同一首，真有人听的出来吗\u0026hellip;\n现梦 -genmu-\r#\r主要想法就是画五角星（致敬传奇风祝东风谷早苗），小巧思是在下一波弹幕中，在之前散开的五角星的每个角的位置（出界了就取刚画好时角的位置）各画一个五角星。最后弹幕效果还是挺好看的，依据五角星画的方向正反，形成两波交替的形状不同的固定弹。\n由于纯固定很容易出安定点，就加了一点蝶弹的自机狙，带点曲线，但是比较稀疏，弹速也还好。还加了向 Boss 移动的大玉，想体现出吸收法力的感觉，但看起来有点抽象\u0026hellip;\n直接看效果吧，传送门\nBullet Dodger\r#\r之前的避弹逻辑中，很抽象的一点在于，它完全没有考虑弹幕是有判定大小的。之前的斥力全是按点做的，也就是说，对于大玉之类的弹幕，自机只会在离它的中心点足够近的时候才感觉危险，这明显是不合理的。\n今天仔细扒了一下 THlib 的文件夹，最后找到一个 bullet.lua 文件，在里面有所有基础弹幕类型的判定范围，拿去喂给 AI 修了避弹逻辑，给所有子弹添加了一个 equiv_radius 属性。\n现在避弹的核心逻辑也很简单，一共八个方向 + 留在原地，分别计算每种情况的代价（通过一个代价函数），之后选取最佳的那个方向即可。当然，难点集中在怎么设计这个代价函数。\n我们可以动用一下人类智慧，想想应该怎么避弹。\n首先我们不希望自机主动往版边跑，因为被封死的可能会变高。所以加入边界惩罚，在到边界距离小于某值时开始生效。离边界越近，惩罚越重。 需要注意的是：版顶的危险度是更高的，大量弹幕会在上方生成，因此我们还设了对上方区域的额外惩罚。\n一般来说，在版面下方的中部，相对安全的同时也便于根据弹幕做后续的响应。我们设定在无威胁情况下，向着这个位置移动。\n对于弹幕，如果位置落在某个子弹的碰撞范围内，会得到一个极大的代价。否则会依据距离给一个指数级衰减的代价。对于 Boss 的体术同理。\n为了让避弹看上去更连贯丝滑，还要加一个对方向突变的惩罚，这个惩罚在完全反向时最大。主要用来防止 AI 避弹中常见的 “抽搐” 现象。\n当然，需要考虑到弹幕的速度与方向的影响。我们会根据当前的速度与方向预测后面 $5$ 帧内子弹的位置，并把每一帧的代价累加。\n思路就是这样，效果很显著，机体没有明显抽动，对大玉的躲避也很成功，遇到密集的下压弹能够选择上穿，也是轻松通过了之前的符卡。所以今天又做了一张符，也是测试一下避弹效果，还是很成功的。\n现在还是没能解决的一点在于 AI 避弹的视野太差了，不会自动寻找弹幕密度低的位置。之后看看能不能从这一点上着手优化吧。\nBye~\n","date":"2 February 2026","externalUrl":null,"permalink":"/posts/bullet-dodger/","section":"Posts","summary":"","title":"Bullet Dodger","type":"posts"},{"content":"hello，米娜桑~\n鸽的这么多天里，主要是摆烂 + 摆弄一些（在我看来）有趣的东西，其中就包括 LuaSTG 。我第一次听说这玩意应该是因为某部同人游戏（大概率是祈华梦），之后也玩过一些算是个人制作的小 Mod ，不过我当时没有考虑过自己做点 STG ，原因也很简单：太菜了。做 STG 需要懂弹设，懂弹设一般飞机技术不会太差，但是我还困在妖E（好像要等到大一下才通😀）。\n大学后时间总归比高中多一点，不过 STG 强度应该是远不如之前的。以前基本每周会打一把，这个时间现在变成了一个月。大一上心血来潮（忘记是不是期中给我心态干崩了）有段时间狂练永N，拿单魔理沙还真打出了第一个 N ，不过后来也没什么热情，直到暑假那会开自动雷混关冲全N（后放弃，星莲船手段极其凶残）。大一上的寒假其实有跟人约着做一个小的单关，然而我当时太鸽了，加上假也不长，最后连文件夹都没建（笑）。最近想着稍微玩一玩吧，还能用 AI 写弹幕代码，今天算是终于做出来一张符卡吧，就写一篇纪念一下。\nBefore Reading\r#\r我想以几首歌作为自制弹幕的主题，第一个就是竹之花。\n如果不知道剧情的还是很推荐去看看原篇的。我一直很推崇用有限的篇幅触动人的作品，竹之花做到了。\n虽然后来听到这首歌多是以二倍速的形式了（难视）。\nFirst Spell Card\r#\r其实之前（ 29 号）为了熟悉一下 Editor Sharp 怎么搭配 AI 食用，已经做过一张符卡了，不过那个纯属 AI 创意。\n下面这张符就是符卡「竹ノ花」，我的最初构想是让绿色米弹模拟竹子，从版底向上长，最后在末端开花。最后竹子弹幕消失，花雨散落。\n由于 1 月 Github Copilot 的额度被我做 CPU 和搭网站烧完了，只能用一些很捞的模型。竹子的处理一直感觉不太像，最后用两排绿色米弹错位并排，感觉差不多就妥协了。一开始做的竹花太稀疏了，都看不出花的形状，后来想做成团簇的形式，但是弹幕量就有些离谱，而且上避的难度有点小，变成纯姿势了。后来也算是妥协做成这样，是让中心相对密一点，但是又向外有一点延伸，不至于画面太空。\n下面是 AI 写的代码，中间调了得有几十次。明天就二月了等我换模型~\nlasttask = task.New(self, function() task.MoveTo(0, 160, 60, MOVE_NORMAL) local rng = Rand() local timer = 0 while true do self.x = 20 * sin(timer * 1.0) for i = 1, 4 do local base_x = -150 \u0026#43; (i - 1) * 100 task.New(self, function() local bamboo_parts = {} local current_flowers = {} local function grow_logic(sx, sy, s_angle, depth, max_j, parts, flowers) local curr_x, curr_y = sx, sy local ang = s_angle for j = 1, max_j do ang = ang \u0026#43; rng:Float(-1.0, 1.0) if ang \u0026lt; 80 then ang = 80 elseif ang \u0026gt; 100 then ang = 100 end local step = 10 local next_x = curr_x \u0026#43; step * cos(ang) local next_y = curr_y \u0026#43; step * sin(ang) local b1 = New(_straight, grain_b, COLOR_GREEN, curr_x, curr_y, 0, ang, false, 0, true, true, 0, false, 0, 0, 0, false) local b2 = New(_straight, grain_b, COLOR_GREEN, curr_x \u0026#43; 5*cos(ang), curr_y \u0026#43; 5*sin(ang), 0, ang, false, 0, true, true, 0, false, 0, 0, 0, false) table.insert(parts, b1) table.insert(parts, b2) -- --- 【新增：竹叶生长逻辑】 --- -- 主干每 6 节长叶，侧枝在中间长叶 if (depth == 0 and j % 6 == 0 and j \u0026lt; max_j - 5) or (depth \u0026gt; 0 and j == 6) then local leaf_side = (rng:Float(0,1) \u0026gt; 0.5 and 1 or -1) for k = 1, 2 do -- 每次成簇长出 2 片叶子 local leaf_ang = ang \u0026#43; leaf_side * rng:Float(40, 70) local leaf = New(_straight, grain_a, COLOR_DEEP_GREEN, curr_x, curr_y, 0, leaf_ang, false, 0, true, true, 0, false, 0, 0, 0, false) table.insert(parts, leaf) leaf_side = leaf_side * -1 -- 左右交错或对称 end end if depth == 0 and j == 26 then local side = (rng:Float(0, 1) \u0026gt; 0.5 and 1 or -1) task.New(self, function() grow_logic(curr_x, curr_y, ang \u0026#43; side * 30, depth \u0026#43; 1, 12, parts, flowers) end) ang = ang - side * 8 end -- 【高密度红色中心花簇】 if j \u0026gt;= (max_j - 1) then local bloom_intensity = 18 \u0026#43; (j - (max_j - 1)) * 4 for n = 1, bloom_intensity do local raw_r = sqrt(rng:Float(0, 1)) * 35 local offset_a = rng:Float(0, 360) local fx = curr_x \u0026#43; (raw_r * 1.2) * cos(offset_a) local fy = curr_y \u0026#43; (raw_r * 0.8) * sin(offset_a) local f_type = (rng:Float(0, 1) \u0026gt; 0.7) and grain_a or ball_small local f_color = (f_type == grain_a) and COLOR_PURPLE or COLOR_RED local flower = New(_straight, f_type, f_color, fx, fy, 0, rng:Float(0, 360), false, 0, true, true, 0, false, 0, 0, 0, false) table.insert(flowers, flower) end end curr_x, curr_y = next_x, next_y task.Wait(4) end end grow_logic(base_x, -260, 90, 0, 46, bamboo_parts, current_flowers) task.Wait(30) task.New(self, function() for k = 1, #bamboo_parts do if IsValid(bamboo_parts[k]) then Del(bamboo_parts[k]) end if k % 30 == 0 then task.Wait(1) end end end) task.Wait(40) for _, flower in ipairs(current_flowers) do if IsValid(flower) then task.New(flower, function() local weight = rng:Float(0, 1) local gravity = 0.005 \u0026#43; (weight * 0.015) flower.vx, flower.vy = rng:Float(-0.4, 0.4), -rng:Float(0, 0.2) * weight local wind_sense = (1.2 - weight) * rng:Float(0.02, 0.04) local friction = 0.97 \u0026#43; (weight * 0.02) while IsValid(flower) do flower.vy = flower.vy - gravity flower.vx = (flower.vx \u0026#43; wind_sense * sin(timer * 2.5 \u0026#43; rng:Float(0, 360))) * friction if flower.vy \u0026lt; -3.5 then flower.vy = -3.5 end task.Wait(1) end end) end end end) end task.Wait(320) timer = timer \u0026#43; 1 end end) 那个注释里写的什么竹叶，我看上去更像是竹节，也就干脆做成深绿色了。\nFinal Scene\r#\r直接放B站链接了，传送门。\n避弹的做法是找到了灵梦机体的 .lua 源码，在里面把灵梦的 frame() 函数换掉了。大致逻辑是每个弹幕给一定斥力，还要注意把自机拉回版底中部，不然会很容易飘到角落被封死。\n之后会继续做一些符卡，再看看能不能优化这个避弹逻辑，或许真要做成一个小项目呢\u0026hellip;\nSomething Unrelated\r#\r29 号东方迷宫 3 出了，听说汉化可能这两天能好，后面必须要尝尝咸淡了。\n最近睡得好晚（起得也好晚），感觉精神有些萎靡啊，调作息吧调作息。\n","date":"31 January 2026","externalUrl":null,"permalink":"/posts/playing-luastg/","section":"Posts","summary":"","title":"Playing LuaSTG...","type":"posts"},{"content":"这几天比较勤奋哈，干脆再更一篇。\n最开始做 CPU M-Extension 的时候，是想实现 SRT 除法的，但是让 copilot 调了很久，烧了很多 token 都还是有问题。加上自己其实也不会（心虚），最后还是写了一个简单的 Radix-16 恢复除法。那个除法器的设计过于恐怖，我直接拿当前余数 $R$ 和 1~15 倍的 $d$ 并行相减比较来确定商位。不过好像大家也都不是很在意这个，两轮 cr 都没有人来拷打这个沟槽的设计。\nXiangShan 的代码中（ nanhu 版）做了好几个除法器，本文主要基于其中的 SRT4Divider。不过我们的重心会还是放在 SRT 除法的原理上，不会涉及到对代码的详细讲解。\nBefore Reading\r#\r依个人观点，写代码时适合听 vocal ，看数学时适合听纯音（雾）。\n考虑到 AV2 对我入坑车万的影响，这首歌确实算是我初入幻想乡的地方了\u0026hellip;\nWhy SRT\r#\r如果你对恢复除法和非恢复除法不了解，最好去恶补一下相关知识。注意甄别内容，我在看非恢复除法时，有一个帖子把 wiki 上的伪代码跟恢复除法的示例混在一起讲，给我晕完了。\n对于恢复除法，为了选择商都必须精确比较 $R$ 和 $d$ 的关系。而且随着基数 $r$ 变大，恢复除法面临很大的比较压力（比如我的沟槽设计），非恢复除法的逻辑则变得很复杂。 SRT 除法不想做 64 位的减法，它希望只通过看 $R$ 和 $d$ 的高几位，通过查表就可以“猜”出一个商，并且保证后续迭代可以修正到正确的结果。\n后面讨论的对象均为 Radix-4 SRT 除法。\n归一化与对齐\r#\rSRT 除法要求将除数左移，让除数位于 $\\left[ 0.5,1 \\right)$ 之间。并对齐被除数。\n为什么一定要控制除数 $d$ 的范围呢？\nSRT 独特的点在于商数集是“冗余”的。Radix-2 恢复除法的商数集是 $\\{ 0,1 \\}$ ，非恢复除法的商数集是 $\\{ -1,1 \\}$ ，最终商的表示应该是唯一的。但是 Radix-2 SRT 的商数集是 $\\{ -1,0,1 \\}$ ，存在可能的多种表示。也就是说，即使高位的商算的“不准”，后续也能救回来。\nSRT 除法的迭代公式如下，其中 $R_j$ 是当前余数， $r$ 是基数： $$R_{j+1} = r \\cdot R_j - q_{j+1} \\cdot d$$考虑 Radix-4 SRT 除法：商数集是 $\\{ -2,-1,0,1,2 \\}$ ，如果余数过大，靠 $- q_{j+1} \\cdot d$ 这项拉不回来时，显然商就有问题了。必须要求迭代方程收敛，那么可以给余数定一个界限 $|R| \\leq \\rho \\cdot d$ 。\n考虑最极端的情况：当前的余数 $R_j$ 已经达到了上限 $\\rho \\cdot d$ ，做最大修正 $R_{j+1} = r \\cdot (\\rho \\cdot d) - q_{max} \\cdot d$ 仍要满足 $\\leq \\rho \\cdot d$ ，于是解不等式：\n$$r \\cdot \\rho \\cdot d - q_{max} \\cdot d \\leq \\rho \\cdot d$$ 得到 $\\rho \\geq \\frac{q_{max}}{r - 1}$ ，对于 Radix-4 ，这个值是 $\\frac{2}{3}$ 。\n回到为什么要归一化除数的问题：假如不归一，除数 $d$ 没有确定的范围。当 $d$ 很小时，SRT 除法的收敛性不能保证，很可能越除余数越大。如果想要提高选商的准确性，就很难只依赖 $R$ 和 $d$ 的高几位确定除数，有悖 SRT 的优化初衷。\n余数的存在形式\r#\r之前我们给出了 SRT 除法的迭代公式，如果每个周期我们做一次减法，那其实并不比非恢复除法好多少。但是如果余数 $R$ 表示成 $Sum(S) + Carry(C)$ ，迭代公式就变成了一个 3 变 2 的加法。有了上期 Wallace Tree 积累的经验，我们知道全加器就能做到。 $$(S_{j+1}, C_{j+1}) = CSA(r \\cdot S_j, r \\cdot C_j, -q_{j+1} \\cdot d)$$也正是因为余数是 $(S, C)$ 形式，我们无法准确的知道它的值（除非做一次 CPA ，但是太慢了）。我们只能依赖 $S$ 和 $C$ 的高几位来“猜”这个商，由于舍弃了 $S$ 和 $C$ 的一些低位，我们相当于忽略了低位会产生的最大进位。截断之后得到的是一个余数的范围。\n之前我们提到，因为商数集的冗余，我们在选择商数时其实是有容错的。可以理解成 $\\{ -2,-1,0,1,2 \\}$ 里每个商数都对应一片区域，只要 $R$ 和 $d$ 落在区域内，选择对应的 $q$ 就是安全的（迭代收敛）。并且这些商数对应的区域会有一些重叠，在重叠区就有多种商数选择。我们拿到的 $R$ 和 $d$ 都会有一定误差，但只要误差比重叠区小，选的商就还是安全的。\n截断保留的位数越多，误差越小。 XiangShan 看了余数的高 7 位和除数的高 4 位，这时误差已经小于重叠区了。\n所谓的 QDS 就是选取商数的模块，做好表后查表就行。\n#\r理解 SRT 除法还是有点难，说实话没有特别好的资料。\nwikipedia 上恢复除法和非恢复除法讲得都挺详细，还附了伪代码，但是 SRT 写的很含糊。我主要的资料来源也就是 XiangShan 和别人的博客，很难说我真的理解了 SRT 除法，至少在硬件实现上还有很多细节我不了解。\n本文的主要目的还是研究 SRT 除法的理论基础，为什么要有冗余的商数集？为什么可以只凭高位选商？希望这些问题在看完本文后能有答案。至于表怎么做，迭代怎么写，好像也都只是比较 technical 的事，我是不太感兴趣的。\n之后大概要远离 HDL 一段时间，其实这几篇文章都是在为 CPU 填坑，然而那两坨屎山都已经留在上个学期了，到此也算仁至义尽。停笔于 27 日凌晨 1 点，夜太深，我要睡力。\n","date":"26 January 2026","externalUrl":null,"permalink":"/posts/srt-division/","section":"Posts","summary":"","title":"SRT Division","type":"posts"},{"content":"幻影忍者前情提要：Wallace Tree (1)\n鸽了几天，期间本来想修修网站的美工，可惜摆了。最后只做了一个 Music Player，还因为网页是静态的不好全局播放（笑）。主页放的是我的网易云红心歌单，如果你有跟我相近的审美，I will feel happy😀。\n本文主要填一下上次的坑，讲一下 XiangShan 的乘法器。采用的是 nanhu 版的代码，完整代码在这里。之后会划分成几个部分细讲一下具体实现。\nBefore Reading\r#\r一文一歌也算是惯例了，也是我红心的曲子，歌单太大首页不一定刷得到，就挂在文章里安利了。\nRewrite 是我很喜欢的作品。今天突然发现 Fall in the Dark 也是这位歌姬唱的，实际东 gal 共荣（喜）。\nBooth 编码\r#\r我们上次讲了最 naive 的二进制乘法，也就是生成部分积，把 32 位乘法变成了 32 次加法。我们注意到，对于二进制乘法 $A\\times B$ ，如果 $B$ 的第 $i$ 位是 0，我们可以直接忽略这一位产生的部分积（为 0）。\n举个例子，如果乘数 $B=00111110$ ，如果按照 naive 的做法，需要将 5 个部分积相加。但是我们在小学阶段就学过：$114514\\times 99=114514\\times \\left( 100-1 \\right) =11451400-114514$ ，这样处理会好算很多。在二进制的例子中，我们可以类似的有： $$ B=\\left( 00111110 \\right) _2=2^5+2^4+2^3+2^2+2^1=2^6-2^1=\\left( 010000\\overline{1}0 \\right) _2 $$ 其中 $\\overline{1}$ 表示 $-1$ 。注意到我们把一串连续的1消掉了，这样只会产生两个部分积。\nRadix-2 Booth\r#\r上面是很符合人类智慧的优化，我们进行推广。假设乘法 $A\\times B$ ，注意到： $$ A=a_{n-1}a_{n-2}...a_1a_0\\left( a_{-1} \\right) $$ $$ =a_{n-1}\\times \\left( -2^{n-1} \\right) +a_{n-2}\\times 2^{n-2}...+a_0\\times 2^0\\ \\text{（补位的}a_{-1}=0\\text{）} $$ $$ =\\left( a_{n-2}-a_{n-1} \\right) \\times 2^{n-1}+\\left( a_{n-3}-a_{n-2} \\right) \\times 2^{n-2}...+\\left( a_0-a_1 \\right) \\times 2^1+\\left( a_{-1}-a_0 \\right) \\times 2^0 $$由上式，可以做如下编码：\n每次移动 1 位，观察 2 位（当前位 $a_i$ 与低位相邻位 $a_{i-1}$）。\n当前位 $a_i$ 右邻位 $a_{i-1}$ 观察到的模式 操作值 对被乘数 $B$ 的操作 0 0 连续的 0 $0$ 无操作 0 1 1 序列结束 $+1$ 加上 $B$ 1 0 1 序列开始 $-1$ 减去 $B$ (加补码) 1 1 连续的 1 $0$ 无操作 这就是 Radix-2 Booth 编码，每次移动一位，观察两位。\nRadix-2 Booth 确实能优化掉之前例子中连续的 1 ，但是当 1 是孤立出现的时候（比如 010 ），部分积反而变多了。下面讲的 Radix-4 Booth 就不会出现这种问题。\nRadix-4 Booth\r#\r如果你的注意力再好一些，会发现： $$ A=\\left( a_{2n+1}a_{2n} \\right) a_{2n-1}a_{2n-2}...a_1a_0\\left( a_{-1} \\right) $$ （其中 $a_{-1}$ 是补位的0， $a_{2n+1},a_{2n}$ 由符号扩展得到。）\n$$ A=a_{2n-1}\\times \\left( -2^{2n-1} \\right) +a_{2n-2}\\times 2^{2n-2}...+a_0\\times 2^0 $$ $$ =\\left( a_{2n-1}+a_{2n}-2a_{2n+1} \\right) \\times 2^{2n}+\\left( a_{2n-3}+a_{2n-2}-2a_{2n-1} \\right) \\times 2^{2n-2}+ $$ $$ ...+\\left( a_1+a_2-2a_3 \\right) \\times 2^2+\\left( a_{-1}+a_0-2a_1 \\right) \\times 2^0 $$ $$ =\\sum_{i=0}^n{\\left( a_{2i-1}+a_{2i}-2a_{2i+1} \\right) \\cdot 2^{2i}} $$由上式，我们可以一次移动两位，观察三位，做如下编码：\n3位编码窗口 $(a_{i+1}, a_i, a_{i-1})$ 代表的操作值 对应代码变量 硬件实现逻辑 000 $0$ 0.U 保持全 0 001 $+1$ b_sext 加被乘数原码 010 $+1$ b_sext 加被乘数原码 011 $+2$ bx2 被乘数左移 1 位 100 $-2$ neg_bx2 被乘数取反左移 1 位 101 $-1$ neg_b 加被乘数补码 110 $-1$ neg_b 加被乘数补码 111 $0$ 0.U 保持全 0 XiangShan 乘法器就是通过 Radix-4 Booth 算法生成部分积。它在求补码和拼接部分积的过程中还有一些小巧思，就不详细写了，可以直接看贴在下面的代码：\nval b_sext, bx2, neg_b, neg_bx2 = Wire(UInt((len\u0026#43;1).W)) b_sext := SignExt(b, len\u0026#43;1) bx2 := b_sext \u0026lt;\u0026lt; 1 neg_b := (~b_sext).asUInt neg_bx2 := neg_b \u0026lt;\u0026lt; 1 val columns: Array[Seq[Bool]] = Array.fill(2*len)(Seq()) var last_x = WireInit(0.U(3.W)) for(i \u0026lt;- Range(0, len, 2)){ val x = if(i==0) Cat(a(1,0), 0.U(1.W)) else if(i\u0026#43;1==len) SignExt(a(i, i-1), 3) else a(i\u0026#43;1, i-1) val pp_temp = MuxLookup(x, 0.U)(Seq( 1.U -\u0026gt; b_sext, 2.U -\u0026gt; b_sext, 3.U -\u0026gt; bx2, 4.U -\u0026gt; neg_bx2, 5.U -\u0026gt; neg_b, 6.U -\u0026gt; neg_b )) val s = pp_temp(len) val t = MuxLookup(last_x, 0.U(2.W))(Seq( 4.U -\u0026gt; 2.U(2.W), 5.U -\u0026gt; 1.U(2.W), 6.U -\u0026gt; 1.U(2.W) )) last_x = x val (pp, weight) = i match { case 0 =\u0026gt; (Cat(~s, s, s, pp_temp), 0) case n if (n==len-1) || (n==len-2) =\u0026gt; (Cat(~s, pp_temp, t), i-2) case _ =\u0026gt; (Cat(1.U(1.W), ~s, pp_temp, t), i-2) } for(j \u0026lt;- columns.indices){ if(j \u0026gt;= weight \u0026amp;\u0026amp; j \u0026lt; (weight \u0026#43; pp.getWidth)){ columns(j) = columns(j) :\u0026#43; pp(j-weight) } } } 列压缩乘法\r#\r上一篇文章介绍了 Wallace Tree 的思想，简单来说就是利用全加器将 3 个部分积压缩成 2 个。每层都能实现一次 3:2 的压缩，在 $O(\\log N)$ 的层数内就能压缩到只剩 2 个部分积相加。\n以 32 位乘法为例。注意到每一个 3:2 压缩，需要一个 64 位压缩器。但其实很多时候低位都是空的，也就是一直做 $+0$ ，会浪费相当一部分的硬件资源。\n这是 wikipedia 上摘下来的图，生成的部分积其实就类似这样，更像是一个平行四边形。图中其实是在按行压缩（每三行做一组压缩），但是这样明显浪费了左上角和右下角的计算空白。\n如果换个角度看，用全加器做压缩避免了进位传播的延迟，那完全可以把每一列视作的压缩过程抽离出来，不再受“行”的限制。当然每一列在压缩过程中，会接收来自后一列的进位，也会进位给前一列。最终目标是压缩到每一列都不超过两个。\naddOneColumn\r#\rdef addOneColumn(col: Seq[Bool], cin: Seq[Bool]): (Seq[Bool], Seq[Bool], Seq[Bool]) = { var sum = Seq[Bool]() var cout1 = Seq[Bool]() var cout2 = Seq[Bool]() col.size match { case 1 =\u0026gt; // do nothing sum = col \u0026#43;\u0026#43; cin case 2 =\u0026gt; val c22 = Module(new C22) c22.io.in := col sum = c22.io.out(0).asBool \u0026#43;: cin cout2 = Seq(c22.io.out(1).asBool) case 3 =\u0026gt; val c32 = Module(new C32) c32.io.in := col sum = c32.io.out(0).asBool \u0026#43;: cin cout2 = Seq(c32.io.out(1).asBool) case 4 =\u0026gt; val c53 = Module(new C53) for((x, y) \u0026lt;- c53.io.in.take(4) zip col){ x := y } c53.io.in.last := (if(cin.nonEmpty) cin.head else 0.U) sum = Seq(c53.io.out(0).asBool) \u0026#43;\u0026#43; (if(cin.nonEmpty) cin.drop(1) else Nil) cout1 = Seq(c53.io.out(1).asBool) cout2 = Seq(c53.io.out(2).asBool) case n =\u0026gt; val cin_1 = if(cin.nonEmpty) Seq(cin.head) else Nil val cin_2 = if(cin.nonEmpty) cin.drop(1) else Nil val (s_1, c_1_1, c_1_2) = addOneColumn(col take 4, cin_1) val (s_2, c_2_1, c_2_2) = addOneColumn(col drop 4, cin_2) sum = s_1 \u0026#43;\u0026#43; s_2 cout1 = c_1_1 \u0026#43;\u0026#43; c_2_1 cout2 = c_1_2 \u0026#43;\u0026#43; c_2_2 } (sum, cout1, cout2) } addOneColumn 的作用是压缩某一列的部分积，具体设计如下：\n如果这一列只有 1 位，无需压缩。（加上进位不超过 2 个） 如果有 2 位，使用半加器。（ C22 压缩器，输出 sum 留在本列，carry 进位） 如果有 3 位，使用全加器。（ C32 压缩器，输出 sum 留在本列，carry 进位） 如果有 4 位，结合来自低位的 1 个进位，凑成 5 位使用 C53 压缩器。 如果 addOneColumn 的这一列还有更多位，将会分组做 addOneColumn 。前四位分成一组，后面的所有位作为第二组。\n这里简单提一下 C53 的实现，它接受 4 个本列输入和 1 个低位进位，输出 1 个 sum 留在本列，和 2 个向高位的进位 carry_1 carry_2。\n$sum=x_1\\oplus x_2\\oplus x_3\\oplus x_4\\oplus c_{in}$ （一直加，很好理解）\n$carry_1 = \\text{Majority}(x_1, x_2, x_3)$ （前三个相加的进位， $\\text{Majority}$ 指的是三者中多数决定，也就是 $(x_1 \\wedge x_2) \\vee (x_2 \\wedge x_3) \\vee (x_1 \\wedge x_3)$ ）\n$carry_2 = \\text{Majority}(x_4, c_{in}, (x_1 \\oplus x_2 \\oplus x_3))$ （前三个的和与 $x_4, c_{in}$ 相加的进位）\naddAll\r#\r之后只要检查是否达到压缩完成的条件（每列最多两位），如果某一列没达到，就调用 addOneColumn 进行压缩。\ndef addAll(cols: Array[Seq[Bool]], depth: Int): (UInt, UInt) = { if(max(cols.map(_.size)) \u0026lt;= 2){ val sum = Cat(cols.map(_(0)).reverse) var k = 0 while(cols(k).size == 1) k = k\u0026#43;1 val carry = Cat(cols.drop(k).map(_(1)).reverse) (sum, Cat(carry, 0.U(k.W))) } else { val columns_next = Array.fill(2*len)(Seq[Bool]()) var cout1, cout2 = Seq[Bool]() for( i \u0026lt;- cols.indices){ val (s, c1, c2) = addOneColumn(cols(i), cout1) columns_next(i) = s \u0026#43;\u0026#43; cout2 cout1 = c1 cout2 = c2 } val needReg = depth == 4 val toNextLayer = if(needReg) columns_next.map(_.map(x =\u0026gt; RegEnable(x, io.regEnables(1)))) else columns_next addAll(toNextLayer, depth\u0026#43;1) } } 代码中的 cout1 cout2 是为了照顾到 C53 压缩器，可以同时存两位进位。但是某列在进行压缩时只会用到 cout1 作为低位进位 $c_{in}$ ，cout2 会直接存到本列并参与下一轮压缩。\n深度为 4 时切了一刀，存进寄存器。 XiangShan 中的乘法占两个流水级，等下一个周期继续压缩。\n写在最后\r#\r以上就是 XiangShan 的乘法器，并没有那么难理解，但是很精巧。里面一些很细的优化和小巧思相当值得品味呢。\n这篇文章动笔于 1 月 25 日，但是写完已经是 1 月 26 号了。中途出门（被迫）去逛了门口的综合体，意外的有人气。上次来南京还是 25 年的春节，不过当时好像一直在往新街口那块跑（饭局有点多），家门口的反而没去过。再往前，印象就停留在 24 年暑假了，不过那个时候综合体疑似（？）还没开。感叹去上海一年半，南通南京都变得很陌生。不过上海也很陌生，一年半进城恐怕没有 5 次（笑）。\n细数了一下，去了两次旦（一次是例会），加上一次幻奏。平均下来半年进一次城，进城还是因为办车万照顾不了偏僻的闵行。\n上次出远门好像还是暑假时 Norb 举行的神秘出游。选在了上海最热的天，去了同样是郊区（所以不算进城）的东方绿舟，一群无聊的大学牲在 $35^{\\circ}\\mathrm{C}$ 的无遮挡空地上走各种桥（公园里很常见那种，各种抽象桥身和造型）。最后热的实在受不了 11 点没到就去找饭吃了，去了一家很实惠的家常菜来着。最后全员体验市域机场线，幸好没打车回去，我在打车来的一个小时中很坚韧地没有吐出来。\n有点恐怖的是刚才为了确认没打错地名打开搜索引擎，发现就在我们去之前一周，东方绿舟还出了事故。难道说那天人那么少也不只是因为天气（？）。\n好吧，回忆就止于此，我都忘了是为什么而感慨的了。诸君晚安。\n","date":"25 January 2026","externalUrl":null,"permalink":"/posts/wallace-tree-2/","section":"Posts","summary":"","title":"Wallace Tree (2)","type":"posts"},{"content":"为了做 CPU M-Extension 的 Bonus 接触到了 Wallace Tree 乘法器，后来的实现也基本是借鉴的这种乘法。结果 cr 的时候因为周期设计不够 balanced 被 TA 拷打了，之后又在 XiangShan 上找到了一个基于 Wallace Tree 的乘法器实现，感觉自己做的那个还是太低级了。\nBefore Reading\r#\r因为没搞定自动播放，就劳烦手动点一下吧，不过估计撑不到你读完本文（笑）。\n原理\r#\r最简单的二进制乘法可能也没有那么 naive ，大致可以用下面的图来解释: 通过简单的分析可以知道，只需要用 $B$ 的每一位分别与 $A$ 相乘得到 $width$ 个部分积（并左移），之后将它们加起来就可以实现乘法。\n得到部分积是很快速的过程，对于第 $i$ 位，只需要将 $B[i]$ 复制 $width$ 位得到 全0 或 全1，之后与 $A$ 做一次 And 操作即可。关键的优化在于累加，因为做 32 次 CPA 的耗时是不能忍受的。\nWallace Tree 给出了一个方案：\n一个 3-2 压缩器本质上就是一个全加器，接受 3 个数 $a,b,c$ 作为输入，输出 2 个数 $sum$ 和 $carry$。把 $carry$ 左移一位后 $carry+sum=a+b+c$ (这是显然的)。通过这样的一个 3-2 压缩器我们实现了把三个数相加变成两个数相加，全加器的各位之间是独立的（每一位都有 $sum=a \\oplus b \\oplus c$，$carry=(a \\wedge b) \\vee (b \\wedge c) \\vee (a \\wedge c)$），避免了 CPA 因需要低位向高位传播信号带来的延迟。\n32 个部分积通过一层的压缩可以变成 22 个，继续逐层压缩最终只剩 2 个部分积，做一次 CPA 即可。\n流水级设计\r#\r在我实现的乘法器中对于一次乘法，要做的内容如下:\n零扩展/符号扩展至 $2*width$ 位宽 生成部分积（ $B$ 的每一位并行地与 $A$ 通过 AND门） 部分积压缩（ 8 层） 一次 CPA （用超前进位加法器实现 64 位加法） 注意：部分积压缩的层与层之间是串联的，每一层需要等待上一层的信号，这会导致压缩的总时间远比每层压缩的时间和要大。把 8 层的压缩全部放在一个周期并不是一个很好的选择。\n在 M1 中，处理符号位和生成部分积都不会有太多延迟，完全可以进行 2 层压缩。 压缩的另一个好处在于：更少的部分积意味着 M1 到 M2 之间存储这些中间结果的寄存器可以减少。\ndef cycle_m1(self): \u0026#34;\u0026#34;\u0026#34; Execute EX_M1 stage: Partial Product Generation \u0026#43; 2 Levels of Compression This stage generates 32 partial products using AND gates, then performs Level 1 (32 → 22) and Level 2 (22 → 15) compression. \u0026#34;\u0026#34;\u0026#34; # Only process if stage 1 is valid with Condition(self.m1_valid[0] == Bits(1)(1)): # Read pipeline registers op1 = self.m1_op1[0] op2 = self.m1_op2[0] op1_signed = self.m1_op1_signed[0] op2_signed = self.m1_op2_signed[0] # ================================================================= # Step 1: Sign/Zero extend operands to 64 bits # ================================================================= op1_ext = sign_zero_extend(op1, op1_signed) # 64-bit extended op1 # ================================================================= # Step 2: Compute signed multiplication correction for MULH # When op2 is signed and negative (op2[31]=1), we need to correct # the result because the MSB represents -2^31 instead of \u0026#43;2^31. # The correction is: subtract op1 from the high 32 bits of result. # ================================================================= need_correction = op2_signed \u0026amp; op2[31:31] signed_correction = need_correction.select(op1, Bits(32)(0)) # ================================================================= # Step 3: Generate 32 Partial Products # For each bit i of op2: pp[i] = (op2[i] ? op1_ext : 0) \u0026lt;\u0026lt; i # ================================================================= # Generate all 32 partial products with correct shifting # Note: For a left shift by i bits, we concat zeros on the right pp0 = op2[0:0].select(op1_ext, Bits(64)(0)) pp1 = op2[1:1].select(concat(op1_ext[0:62], Bits(1)(0)), Bits(64)(0)) pp2 = op2[2:2].select(concat(op1_ext[0:61], Bits(2)(0)), Bits(64)(0)) pp3 = op2[3:3].select(concat(op1_ext[0:60], Bits(3)(0)), Bits(64)(0)) pp4 = op2[4:4].select(concat(op1_ext[0:59], Bits(4)(0)), Bits(64)(0)) pp5 = op2[5:5].select(concat(op1_ext[0:58], Bits(5)(0)), Bits(64)(0)) pp6 = op2[6:6].select(concat(op1_ext[0:57], Bits(6)(0)), Bits(64)(0)) pp7 = op2[7:7].select(concat(op1_ext[0:56], Bits(7)(0)), Bits(64)(0)) pp8 = op2[8:8].select(concat(op1_ext[0:55], Bits(8)(0)), Bits(64)(0)) pp9 = op2[9:9].select(concat(op1_ext[0:54], Bits(9)(0)), Bits(64)(0)) pp10 = op2[10:10].select(concat(op1_ext[0:53], Bits(10)(0)), Bits(64)(0)) pp11 = op2[11:11].select(concat(op1_ext[0:52], Bits(11)(0)), Bits(64)(0)) pp12 = op2[12:12].select(concat(op1_ext[0:51], Bits(12)(0)), Bits(64)(0)) pp13 = op2[13:13].select(concat(op1_ext[0:50], Bits(13)(0)), Bits(64)(0)) pp14 = op2[14:14].select(concat(op1_ext[0:49], Bits(14)(0)), Bits(64)(0)) pp15 = op2[15:15].select(concat(op1_ext[0:48], Bits(15)(0)), Bits(64)(0)) pp16 = op2[16:16].select(concat(op1_ext[0:47], Bits(16)(0)), Bits(64)(0)) pp17 = op2[17:17].select(concat(op1_ext[0:46], Bits(17)(0)), Bits(64)(0)) pp18 = op2[18:18].select(concat(op1_ext[0:45], Bits(18)(0)), Bits(64)(0)) pp19 = op2[19:19].select(concat(op1_ext[0:44], Bits(19)(0)), Bits(64)(0)) pp20 = op2[20:20].select(concat(op1_ext[0:43], Bits(20)(0)), Bits(64)(0)) pp21 = op2[21:21].select(concat(op1_ext[0:42], Bits(21)(0)), Bits(64)(0)) pp22 = op2[22:22].select(concat(op1_ext[0:41], Bits(22)(0)), Bits(64)(0)) pp23 = op2[23:23].select(concat(op1_ext[0:40], Bits(23)(0)), Bits(64)(0)) pp24 = op2[24:24].select(concat(op1_ext[0:39], Bits(24)(0)), Bits(64)(0)) pp25 = op2[25:25].select(concat(op1_ext[0:38], Bits(25)(0)), Bits(64)(0)) pp26 = op2[26:26].select(concat(op1_ext[0:37], Bits(26)(0)), Bits(64)(0)) pp27 = op2[27:27].select(concat(op1_ext[0:36], Bits(27)(0)), Bits(64)(0)) pp28 = op2[28:28].select(concat(op1_ext[0:35], Bits(28)(0)), Bits(64)(0)) pp29 = op2[29:29].select(concat(op1_ext[0:34], Bits(29)(0)), Bits(64)(0)) pp30 = op2[30:30].select(concat(op1_ext[0:33], Bits(30)(0)), Bits(64)(0)) pp31 = op2[31:31].select(concat(op1_ext[0:32], Bits(31)(0)), Bits(64)(0)) # ================================================================= # Step 4: Wallace Tree Compression Level 1 (32 → 22 rows) # ================================================================= # Level 1: 32 → 22 rows (10 groups of 3, 2 passthrough) s1_0, c1_0 = full_adder_64bit(pp0, pp1, pp2) s1_1, c1_1 = full_adder_64bit(pp3, pp4, pp5) s1_2, c1_2 = full_adder_64bit(pp6, pp7, pp8) s1_3, c1_3 = full_adder_64bit(pp9, pp10, pp11) s1_4, c1_4 = full_adder_64bit(pp12, pp13, pp14) s1_5, c1_5 = full_adder_64bit(pp15, pp16, pp17) s1_6, c1_6 = full_adder_64bit(pp18, pp19, pp20) s1_7, c1_7 = full_adder_64bit(pp21, pp22, pp23) s1_8, c1_8 = full_adder_64bit(pp24, pp25, pp26) s1_9, c1_9 = full_adder_64bit(pp27, pp28, pp29) # Passthrough: pp30, pp31 # Level 1 output: 22 rows total (10 sum outputs: s1_0..s1_9, 10 carry outputs: c1_0..c1_9, 2 passthrough: pp30, pp31) # ================================================================= # Step 5: Wallace Tree Compression Level 2 (22 → 15 rows) # ================================================================= # Level 2: 22 → 15 rows (7 groups of 3, 1 passthrough) s2_0, c2_0 = full_adder_64bit(s1_0, c1_0, s1_1) s2_1, c2_1 = full_adder_64bit(c1_1, s1_2, c1_2) s2_2, c2_2 = full_adder_64bit(s1_3, c1_3, s1_4) s2_3, c2_3 = full_adder_64bit(c1_4, s1_5, c1_5) s2_4, c2_4 = full_adder_64bit(s1_6, c1_6, s1_7) s2_5, c2_5 = full_adder_64bit(c1_7, s1_8, c1_8) s2_6, c2_6 = full_adder_64bit(s1_9, c1_9, pp30) # Passthrough: pp31 # Level 2 output: 15 rows total (7 sum outputs: s2_0..s2_6, 7 carry outputs: c2_0..c2_6, 1 passthrough: pp31) # ================================================================= # Store 15 intermediate rows in stage 2 pipeline registers # ================================================================= self.m2_valid[0] = Bits(1)(1) self.m2_result_high[0] = self.m1_result_high[0] self.m2_rd[0] = self.m1_rd[0] self.m2_signed_correction[0] = signed_correction # Store all 15 intermediate rows self.m2_row0[0] = s2_0 self.m2_row1[0] = c2_0 self.m2_row2[0] = s2_1 self.m2_row3[0] = c2_1 self.m2_row4[0] = s2_2 self.m2_row5[0] = c2_2 self.m2_row6[0] = s2_3 self.m2_row7[0] = c2_3 self.m2_row8[0] = s2_4 self.m2_row9[0] = c2_4 self.m2_row10[0] = s2_5 self.m2_row11[0] = c2_5 self.m2_row12[0] = s2_6 self.m2_row13[0] = c2_6 self.m2_row14[0] = pp31 # Clear stage 1 self.m1_valid[0] = Bits(1)(0) M2 只需要用 full_adder_64bit 继续压缩，直到只剩下两个数 $sum$ 和 $carry$ 即可。\ndef cycle_m2(self): \u0026#34;\u0026#34;\u0026#34; Execute EX_M2 stage: Wallace Tree Compression Levels 3-8 (15 → 2 rows) This stage continues Wallace Tree compression from 15 rows down to 2 rows. \u0026#34;\u0026#34;\u0026#34; # Only process if stage 2 is valid with Condition(self.m2_valid[0] == Bits(1)(1)): # Read all 15 intermediate rows from pipeline registers # From Level 2 output: s2_0..s2_6, c2_0..c2_6, pp31 s2_0 = self.m2_row0[0] c2_0 = self.m2_row1[0] s2_1 = self.m2_row2[0] c2_1 = self.m2_row3[0] s2_2 = self.m2_row4[0] c2_2 = self.m2_row5[0] s2_3 = self.m2_row6[0] c2_3 = self.m2_row7[0] s2_4 = self.m2_row8[0] c2_4 = self.m2_row9[0] s2_5 = self.m2_row10[0] c2_5 = self.m2_row11[0] s2_6 = self.m2_row12[0] c2_6 = self.m2_row13[0] pp31 = self.m2_row14[0] # ================================================================= # Wallace Tree Compression Levels 3-8 (15 → 2 rows) # ================================================================= # Level 3: 15 → 10 rows (5 groups of 3) s3_0, c3_0 = full_adder_64bit(s2_0, c2_0, s2_1) s3_1, c3_1 = full_adder_64bit(c2_1, s2_2, c2_2) s3_2, c3_2 = full_adder_64bit(s2_3, c2_3, s2_4) s3_3, c3_3 = full_adder_64bit(c2_4, s2_5, c2_5) s3_4, c3_4 = full_adder_64bit(s2_6, c2_6, pp31) # Level 3 output: 10 rows # Level 4: 10 → 7 rows (3 groups of 3, 1 passthrough) s4_0, c4_0 = full_adder_64bit(s3_0, c3_0, s3_1) s4_1, c4_1 = full_adder_64bit(c3_1, s3_2, c3_2) s4_2, c4_2 = full_adder_64bit(s3_3, c3_3, s3_4) # Passthrough: c3_4 # Level 4 output: 7 rows # Level 5: 7 → 5 rows (2 groups of 3, 1 passthrough) s5_0, c5_0 = full_adder_64bit(s4_0, c4_0, s4_1) s5_1, c5_1 = full_adder_64bit(c4_1, s4_2, c4_2) # Passthrough: c3_4 # Level 5 output: 5 rows # Level 6: 5 → 4 rows (1 group of 3, 2 passthrough) s6_0, c6_0 = full_adder_64bit(s5_0, c5_0, s5_1) # Passthrough: c5_1, c3_4 # Level 6 output: 4 rows # Level 7: 4 → 3 rows (1 group of 3, 1 passthrough) s7_0, c7_0 = full_adder_64bit(s6_0, c6_0, c5_1) # Passthrough: c3_4 # Level 7 output: 3 rows # Level 8: 3 → 2 rows (final Wallace Tree compression) s8_final, c8_final = full_adder_64bit(s7_0, c7_0, c3_4) # Final 2 rows: s8_final, c8_final # ================================================================= # Store final 2 rows in stage 3 pipeline registers # ================================================================= self.m3_valid[0] = Bits(1)(1) self.m3_result_high[0] = self.m2_result_high[0] self.m3_rd[0] = self.m2_rd[0] self.m3_signed_correction[0] = self.m2_signed_correction[0] # Store the 2 final rows self.m3_row0[0] = s8_final self.m3_row1[0] = c8_final # Clear stage 2 self.m2_valid[0] = Bits(1)(0) M3 需要注意一个符号修正的问题：$product_{64} = sum + carry + (-correction \\ll 32)$ 如果正常去做，会多一个减法的延迟（可以单独一个周期的程度），但是上面的写法也表明了我们可以将其视作 3 个数相加，用一次全加器就可以压缩成 2 个数相加。最后只用一次 CLA 获得最终结果。\ndef cycle_m3(self): \u0026#34;\u0026#34;\u0026#34; Execute EX_M3 stage: Final Addition using Carry-Lookahead Adder (CLA) This stage completes the multiplication by adding the final 2 rows using a carry-lookahead adder, with signed correction integrated via 3:2 compression. \u0026#34;\u0026#34;\u0026#34; # Only process if stage 3 is valid and result is not already ready with Condition((self.m3_valid[0] == Bits(1)(1)) \u0026amp; (self.m3_result_ready[0] == Bits(1)(0))): # Read the 2 final rows from pipeline registers s8_final = self.m3_row0[0] c8_final = self.m3_row1[0] signed_correction = self.m3_signed_correction[0] # ================================================================= # Integrate signed correction using 3:2 compression # Instead of computing: product_64 = sum \u0026#43; carry, then high -= correction # We compute: product_64 = sum \u0026#43; carry \u0026#43; (-correction \u0026lt;\u0026lt; 32) # # To subtract correction from high 32 bits, we add the two\u0026#39;s complement: # -correction = ~correction \u0026#43; 1 # We place this in bits [32:63] and handle the \u0026#43;1 in the carry row # ================================================================= # Create the correction value as a 64-bit number positioned in high 32 bits # correction_neg_high represents ~signed_correction in bits [32:63] correction_inv = ~signed_correction # Inverted bits for two\u0026#39;s complement correction_neg_64 = concat(correction_inv, Bits(32)(0)) # Place in high 32 bits # For the \u0026#43;1 of two\u0026#39;s complement, we add 1 at bit 32 # This can be merged into the carry row at position 32 # Create a 64-bit value with 1 at bit position 32 (i.e., 0x100000000) correction_plus_one = Bits(64)(0x100000000) # 1 \u0026lt;\u0026lt; 32 # Use 3:2 compressor to merge s8_final, c8_final, and correction_neg_64 s9_0, c9_0 = full_adder_64bit(s8_final, c8_final, correction_neg_64) # Use another 3:2 compressor to merge s9_0, c9_0, and correction_plus_one s_final, c_final = full_adder_64bit(s9_0, c9_0, correction_plus_one) # ================================================================= # CLA (Carry-Lookahead Adder) - Final Addition # Now we have integrated the signed correction into the compression # ================================================================= product_64 = carry_lookahead_adder_64bit(s_final, c_final) # Select which 32 bits to return based on operation type partial_low = product_64[0:31].bitcast(Bits(32)) partial_high = product_64[32:63].bitcast(Bits(32)) result = self.m3_result_high[0].select( partial_high, # High 32 bits for MULH/MULHSU/MULHU partial_low # Low 32 bits for MUL ) # Store final result and mark as ready self.m3_result[0] = result self.m3_result_ready[0] = Bits(1)(1) # Clear valid flag since processing is complete self.m3_valid[0] = Bits(1)(0) 里面其实还有很多可以优化的地方，但是限于个人目前水平（以及不想为沟槽的 Assassyn 再折腾），大概就到此为止了。下次可能会写一些关于 XiangShan 所实现的乘法器的东西，不过下次的事就下次再说吧（笑）。\nSomething Unrelated\u0026hellip;\r#\r找了一首比较长的，边看帖边听歌很不错的说。\n（btw: 花都是真好听啊，怎么改都好听那种！）\n之后找个时间把网站的美工搞搞好吧，现在暗色还看的过去，浅色丑的看不下去（）。\n","date":"21 January 2026","externalUrl":null,"permalink":"/posts/wallace-tree-1/","section":"Posts","summary":"","title":"Wallace Tree (1)","type":"posts"},{"content":"\rBirth！\r#\r这是我用 Blowfish 搭建的博客。\n并不是有了什么想记录的东西才开了这个Blog，而是觉得这种方式能push自己写一点东西。其实从PPCA的时候就应该写点的，但是写完Ray-Tracer后有点摆，之后就被各种不可名状的东西硬控到现在（悲）。写Blog本身是为了找点乐子，顺手记录点东西，应该也是挺好的。\n我没有写日记的习惯，也是第一次写Blog，难免有点流水账，权当是语言能力的康复训练就好。这篇一是测试下网站，二是交代一下博客的缘由，后续估计什么都会写点，别太懒就行（笑）。\n听首歌吧\r#\r高中时很喜欢这张专来着，这首编曲也很舒服。昨天日推又刷到，不知道为什么没有红心……\n","date":"19 January 2026","externalUrl":null,"permalink":"/posts/hello-world/","section":"Posts","summary":"","title":"Hello World","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"Hi！这里是 Youming 的小站，记录正在进行的学习、想法以及一些个人生活。\n我目前是上海交通大学 ACM 班的一名本科生。\n还在探索研究方向。 喜欢音乐、动漫与剧情类游戏，对棋类很感兴趣。 写下来的东西主要是给未来的自己备忘，也欢迎交流。 如果你想联系我，可以发邮件到 dxuanming@sjtu.edu.cn。 这个页面会慢慢扩充，之后准备放上一些常驻信息，例如我正在读的书、做的项目以及音乐歌单。敬请期待。\n","externalUrl":null,"permalink":"/about/","section":"关于","summary":"","title":"关于","type":"page"}]